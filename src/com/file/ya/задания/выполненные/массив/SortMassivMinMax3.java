package com.file.ya.задания.выполненные.массив;

import java.util.Arrays;

public class SortMassivMinMax3 {


    public static void main(String[] args) {
        int myArr[] = {2, 4, 3, 1, 5, -1, 0, 9, 6, 7, 8, 10};

//        boolean sorted = false;
//        while (!sorted) {
//            sorted = true;


            for (int i = 0; i < myArr.length - 1; i++) {
                for (int j = 0; j < myArr.length - 1 - i; j++) {
                    if (myArr[j] < myArr[j + 1]) {
                        замена(myArr, j);

                    }

                }

            }
        System.out.println(Arrays.toString(myArr));
        }

//    }

    //    Варианты  кода №/№ 1,2,3  отличаются структурой. В одном (№2 )случае есть отдельный метод ЗАМЕНА,
//    в теле класса , в другом (№3) , тело метода ЗАМЕНА прописано в теле вложенного цикла for
//    Я так понимаю, что если метод прописан отдельно, то к нему можно обращаться сколько угодно раз
//    из иных мест программы через имя класса, раз он статик, если код тела метода ЗАМЕНА используется
//    для вычисления  в цикле fоr, то это просто часть кода цикла никуда более не применима?
    private static void замена(int myArr[], int i) {
        int t = myArr[i];
        myArr[i] = myArr[(i + 1)];
        myArr[(i + 1)] = t;
    }
}
// Вывод в консоль специально сделан пошагово, что бы видеть количество повторений. Здесь их 11,
// элементов массива -12. Т.е. программе потребовалось 11 циклов.
// В варианте № 2 повторений потебовалось всего 4, код вычисления несколько другой. Как это работает, честно сказать
// не разобрался.нО, Очевидно, что если остановить проверку после четвертой итерации,
// то прогрпмма будет работать быстрее
